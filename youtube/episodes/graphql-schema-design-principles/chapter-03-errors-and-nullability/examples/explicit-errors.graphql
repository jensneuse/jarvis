# Bad: Generic errors â€” client must parse strings
type Mutation {
  createOrder(input: CreateOrderInput!): Order
  # On failure: { "errors": [{ "message": "Item out of stock" }] }
  # Client: if (error.message.includes("out of stock")) { ... } ðŸ˜¬
}

# Good: Typed results â€” client gets exhaustive handling
type Mutation {
  createOrder(input: CreateOrderInput!): CreateOrderResult!
}

union CreateOrderResult =
  | Order
  | OutOfStockError
  | InvalidAddressError
  | PaymentDeclinedError

type OutOfStockError {
  message: String!
  itemId: ID!
  availableQuantity: Int!
}

type InvalidAddressError {
  message: String!
  field: String!
  suggestion: String
}

type PaymentDeclinedError {
  message: String!
  retryable: Boolean!
}
